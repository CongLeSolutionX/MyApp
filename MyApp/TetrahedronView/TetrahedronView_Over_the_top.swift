//
//  TetrahedronView_Over_the_top.swift
//  MyApp
//
//  Created by Cong Le on 5/3/25.
//

//  Description:
//  This file defines a SwiftUI view hierarchy that displays a 3D rotating
//  wireframe tetrahedron rendered using Apple's Metal framework. It adapts the
//  Octahedron example, demonstrating:
//  - Embedding MTKView in SwiftUI via UIViewRepresentable.
//  - Basic Metal pipeline setup (shaders, buffers, states).
//  - Defining geometry (vertices, indices) for a TETRAHEDRON.
//  - SIMD matrix transformations (Model-View-Projection).
//  - Animation via per-frame rotation.
//  - Depth testing.
//  - Wireframe rendering.
//
import SwiftUI
import MetalKit // Provides MTKView and Metal integration helpers
import simd    // Provides efficient vector and matrix types/operations

// MARK: - Metal Shaders (Embedded String)

/// Contains the source code for the Metal vertex and fragment shaders as a single string.
/// These shaders are compiled at runtime and executed on the GPU.
///
/// - Vertex Shader (`tetrahedron_vertex_shader`): Processes each incoming vertex. It transforms the vertex position from model space to clip space using the Model-View-Projection (MVP) matrix provided by the `Uniforms` buffer and passes the vertex color to the fragment shader.
/// - Fragment Shader (`tetrahedron_fragment_shader`): Processes each pixel fragment generated by the rasterizer. It receives the interpolated color from the vertex shader and outputs it as the final pixel color.
let tetrahedronMetalShaderSource = """
#include <metal_stdlib> // Import the Metal Standard Library

using namespace metal; // Use the Metal namespace

// --- Data Structures Passed Between CPU and GPU ---

// Structure defining vertex input data received from the CPU (Swift code).
// Corresponds to the 'TetrahedronVertex' Swift struct and the layout
// described by the 'MTLVertexDescriptor'.
struct VertexIn {
    float3 position [[attribute(0)]]; // Vertex position in model space (bound to attribute index 0)
    float4 color    [[attribute(1)]]; // Vertex color (RGBA) (bound to attribute index 1)
};

// Structure defining data passed from the vertex shader output to the fragment shader input.
// The GPU interpolates these values across the surface of the triangle.
struct VertexOut {
    float4 position [[position]]; // Final vertex position in clip space (REQUIRED by rasterizer)
    float4 color;               // Interpolated vertex color
};

// Structure for uniform data (constants applied to all vertices in a draw call)
// passed from the CPU. Corresponds to the 'Uniforms' Swift struct.
struct Uniforms {
    float4x4 modelViewProjectionMatrix; // Combined Model-View-Projection transformation matrix
};

// --- Vertex Shader ---
// Executed once per vertex in the draw call.
// Takes vertex data and uniforms, outputs transformed position and other data for the fragment shader.
vertex VertexOut tetrahedron_vertex_shader(
    const device VertexIn *vertices [[buffer(0)]], // Array of vertices from the vertex buffer (bound to buffer index 0)
    const device Uniforms &uniforms [[buffer(1)]], // Uniform data structure (bound to buffer index 1)
    unsigned int vid [[vertex_id]]                 // System-provided index of the current vertex being processed
) {
    VertexOut out; // Structure to hold the output of this shader stage
    VertexIn currentVertex = vertices[vid]; // Get the specific vertex data for this execution instance
    
    // Transform the 3D vertex position into 4D homogeneous coordinates (adding w=1)
    // and multiply by the MVP matrix to get the final clip space position.
    out.position = uniforms.modelViewProjectionMatrix * float4(currentVertex.position, 1.0);
    
    // Pass the original vertex color through. It will be interpolated for the fragment shader.
    out.color = currentVertex.color;
    
    return out; // Return the processed vertex data
}

// --- Fragment Shader ---
// Executed once per fragment (potential pixel) after rasterization.
// Determines the final color of the fragment.
fragment half4 tetrahedron_fragment_shader(
    VertexOut in [[stage_in]] // Interpolated data received from the vertex shader output
) {
    // Simply return the interpolated color received from the vertex shader.
    // 'half4' is used for potentially better performance on some GPUs for color output.
    return half4(in.color);
}
"""

// MARK: - Swift Data Structures (Matching Shaders)

/// Swift structure mirroring the `Uniforms` struct in the Metal shader code.
/// This structure holds data that is constant for all vertices within a single draw call,
/// such as the transformation matrix. It will be copied into the `uniformBuffer`.
struct Uniforms {
    /// The combined Model-View-Projection matrix used to transform vertex positions.
    var modelViewProjectionMatrix: matrix_float4x4
}

/// Structure defining the layout of individual vertex data in Swift.
/// This must exactly match the layout of the `VertexIn` struct in the Metal shader
/// and the configuration specified in the `MTLVertexDescriptor`.
struct TetrahedronVertex {
    /// The 3D position of the vertex in model space (x, y, z).
    var position: SIMD3<Float>
    /// The color associated with the vertex (red, green, blue, alpha).
    var color: SIMD4<Float>
}

// MARK: - Renderer Class (Handles Metal Logic)

/// Manages all Metal-related setup, resource creation, and rendering logic for the tetrahedron.
/// It acts as the delegate for the `MTKView`, responding to drawing requests and resize events.
class TetrahedronRenderer: NSObject, MTKViewDelegate {

    /// The Metal device (GPU) used for rendering.
    let device: MTLDevice
    /// The queue used to send rendering commands to the GPU.
    let commandQueue: MTLCommandQueue
    /// The compiled shader pipeline state object, defining the vertex and fragment shaders to use.
    var pipelineState: MTLRenderPipelineState!
    /// The state object defining depth testing parameters (e.g., comparison function, write enabled).
    var depthState: MTLDepthStencilState!

    /// GPU buffer holding the tetrahedron's vertex data (`TetrahedronVertex` structs).
    var vertexBuffer: MTLBuffer!
    /// GPU buffer holding the indices that define the tetrahedron's triangles.
    var indexBuffer: MTLBuffer!
    /// GPU buffer holding the `Uniforms` data (specifically the MVP matrix).
    var uniformBuffer: MTLBuffer!

    /// Current rotation angle (in radians) applied to the model, updated each frame for animation.
    var rotationAngle: Float = 0.0
    /// The aspect ratio of the view/drawable, used for the projection matrix calculation. Updated on resize.
    var aspectRatio: Float = 1.0

    // MARK: Geometry Data
    
    /// Array defining the 4 unique vertices of the tetrahedron.
    /// Each vertex includes a 3D position and an RGBA color.
    /// Coordinates are chosen to form a regular tetrahedron, roughly centered around the origin.
    let vertices: [TetrahedronVertex] = [
        // Format: TetrahedronVertex(position: SIMD3<Float>(x, y, z), color: SIMD4<Float>(r, g, b, a))
        
        // Tip Vertex (highest point)
        TetrahedronVertex(position: SIMD3<Float>( 0.0,    0.707,  0.0   ), color: SIMD4<Float>(1, 0, 0, 1)), // Index 0: Top (Red)
        
        // Base Vertices (forming an equilateral triangle in the XZ plane below the tip)
        TetrahedronVertex(position: SIMD3<Float>( 0.0,   -0.353,  0.816), color: SIMD4<Float>(0, 1, 0, 1)), // Index 1: Base Front (Green)
        TetrahedronVertex(position: SIMD3<Float>( 0.943, -0.353, -0.408), color: SIMD4<Float>(0, 0, 1, 1)), // Index 2: Base Right (Blue)
        TetrahedronVertex(position: SIMD3<Float>(-0.943, -0.353, -0.408), color: SIMD4<Float>(1, 1, 0, 1)), // Index 3: Base Left (Yellow)
    ]

    /// Array of indices defining the 4 triangular faces of the tetrahedron.
    /// Each sequence of three `UInt16` indices references elements in the `vertices` array
    /// to form a single triangle primitive. The order defines the front face (for culling)
    /// and should be counter-clockwise (CCW) when viewed from outside the tetrahedron.
    /// Total Indices = 4 faces * 3 vertices/face = 12.
    let indices: [UInt16] = [
        // Face 1: Front-Right Side Triangle (Top -> Base Front -> Base Right)
        0, 1, 2, // Uses vertices at indices 0, 1, 2
        
        // Face 2: Back-Right Side Triangle (Top -> Base Right -> Base Left)
        0, 2, 3, // Uses vertices at indices 0, 2, 3
        
        // Face 3: Back-Left Side Triangle (Top -> Base Left -> Base Front)
        0, 3, 1, // Uses vertices at indices 0, 3, 1
        
        // Face 4: Bottom Base Triangle (Connecting the three base vertices)
        // Ensure CCW winding when viewed from *below* (outside) the tetrahedron.
        // If looking from above, this would appear clockwise.
        1, 3, 2 // Uses vertices at indices 1, 3, 2
    ]
    
    // MARK: Initialization
    
    /// Initializes the renderer with a Metal device. Creates essential objects like the command queue
    /// and allocates GPU buffers for geometry and uniforms. Configures depth testing state.
    /// - Parameter device: The `MTLDevice` (GPU) to use for rendering.
    /// - Returns: An initialized `TetrahedronRenderer` instance, or `nil` if essential Metal objects cannot be created.
    init?(device: MTLDevice) {
        self.device = device
        // Create a command queue for submitting work to the device
        guard let queue = device.makeCommandQueue() else {
            print("Could not create command queue")
            return nil // Initialization fails if command queue cannot be created
        }
        self.commandQueue = queue
        super.init() // Call NSObject's initializer
        
        // Create and populate GPU buffers
        setupBuffers()
        // Configure the depth testing state
        setupDepthStencil()
    }

    /// Configures the Metal render pipeline state based on the `MTKView`'s pixel formats.
    /// This needs to be called *after* the `MTKView` is created and its properties (like pixel formats) are set.
    /// - Parameter metalKitView: The `MTKView` instance being used for rendering.
    func configure(metalKitView: MTKView) {
        setupPipeline(metalKitView: metalKitView)
    }

    // MARK: Setup Functions

    /// Compiles the Metal shaders from the source string and creates the `MTLRenderPipelineState` object.
    /// Configures the pipeline descriptor with vertex/fragment functions, pixel formats, and the vertex descriptor.
    /// - Parameter metalKitView: The `MTKView` providing the necessary pixel format information.
    /// - Note: This function `fatalError`s if pipeline creation fails, as rendering cannot proceed.
    func setupPipeline(metalKitView: MTKView) {
        do {
            // Create a Metal library from the embedded shader source code
            let library = try device.makeLibrary(source: tetrahedronMetalShaderSource, options: nil)
            
            // Get references to the compiled vertex and fragment shader functions from the library
            guard let vertexFunction = library.makeFunction(name: "tetrahedron_vertex_shader"),
                  let fragmentFunction = library.makeFunction(name: "tetrahedron_fragment_shader") else {
                fatalError("Could not load shader functions from library. Check function names.")
            }

            // Create a pipeline descriptor to configure the render pipeline state
            let pipelineDescriptor = MTLRenderPipelineDescriptor()
            pipelineDescriptor.label = "Wireframe Tetrahedron Pipeline"
            pipelineDescriptor.vertexFunction = vertexFunction
            pipelineDescriptor.fragmentFunction = fragmentFunction
            
            // Set the pixel format for the color render target (must match the MTKView's)
            pipelineDescriptor.colorAttachments[0].pixelFormat = metalKitView.colorPixelFormat
            // Set the pixel format for the depth buffer (must match the MTKView's)
            pipelineDescriptor.depthAttachmentPixelFormat = metalKitView.depthStencilPixelFormat

            // --- Vertex Descriptor ---
            // Describes how vertex data (`TetrahedronVertex`) is organized in memory
            // for the vertex shader (`VertexIn`).
            let vertexDescriptor = MTLVertexDescriptor()
            
            // Attribute 0: Position (float3)
            vertexDescriptor.attributes[0].format = .float3 // Data type
            vertexDescriptor.attributes[0].offset = 0 // Byte offset within the struct
            vertexDescriptor.attributes[0].bufferIndex = 0 // Index of the buffer in setVertexBuffer call
            
            // Attribute 1: Color (float4)
            vertexDescriptor.attributes[1].format = .float4 // Data type
            // Offset is after the position data
            vertexDescriptor.attributes[1].offset = MemoryLayout<SIMD3<Float>>.stride
            vertexDescriptor.attributes[1].bufferIndex = 0 // Same buffer as position
            
            // Layout 0: Defines the stride (total size) of one complete vertex structure
            vertexDescriptor.layouts[0].stride = MemoryLayout<TetrahedronVertex>.stride
            // How often the vertex shader reads data (per vertex)
            vertexDescriptor.layouts[0].stepRate = 1
            vertexDescriptor.layouts[0].stepFunction = .perVertex

            // Assign the configured vertex descriptor to the pipeline descriptor
            pipelineDescriptor.vertexDescriptor = vertexDescriptor

            // Create the immutable render pipeline state object
            pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)

        } catch {
            // If pipeline creation fails, it's a critical error
            fatalError("Failed to create Metal Render Pipeline State: \(error)")
        }
    }

    /// Creates GPU buffers (`MTLBuffer`) and copies vertex, index, and initial uniform data into them.
    /// Calculates buffer sizes based on the `vertices` and `indices` arrays.
    /// - Note: This function `fatalError`s if buffer creation fails.
    func setupBuffers() {
        // --- Vertex Buffer ---
        // Calculate the total size needed for all vertex data.
        let vertexDataSize = vertices.count * MemoryLayout<TetrahedronVertex>.stride
        // Create a GPU buffer and initialize it with the vertex data.
        guard let vBuffer = device.makeBuffer(bytes: vertices, length: vertexDataSize, options: []) else {
            fatalError("Could not create vertex buffer for Tetrahedron")
        }
        vertexBuffer = vBuffer
        vertexBuffer.label = "Tetrahedron Vertices" // Assign a debug label

        // --- Index Buffer ---
        // Calculate the total size needed for all index data (UInt16).
        let indexDataSize = indices.count * MemoryLayout<UInt16>.stride
        // Create a GPU buffer and initialize it with the index data.
        guard let iBuffer = device.makeBuffer(bytes: indices, length: indexDataSize, options: []) else {
            fatalError("Could not create index buffer for Tetrahedron")
        }
        indexBuffer = iBuffer
        indexBuffer.label = "Tetrahedron Indices" // Assign a debug label

        // --- Uniform Buffer ---
        // Allocate buffer sized for one 'Uniforms' struct. Use stride for proper alignment.
        let uniformBufferSize = MemoryLayout<Uniforms>.stride
        // Create an empty buffer. We'll update its contents each frame.
        // .storageModeShared allows both CPU and GPU to access the buffer memory directly (on unified memory architectures).
        guard let uBuffer = device.makeBuffer(length: uniformBufferSize, options: .storageModeShared) else {
            fatalError("Could not create uniform buffer")
        }
        uniformBuffer = uBuffer
        uniformBuffer.label = "Uniforms Buffer (MVP - Tetrahedron)" // Assign a debug label
    }

    /// Creates the `MTLDepthStencilState` object to configure depth testing.
    /// Enables depth testing (`depthCompareFunction = .less`) and allows writing to the depth buffer (`isDepthWriteEnabled = true`).
    /// This ensures that fragments closer to the camera correctly obscure fragments farther away.
    /// - Note: This function `fatalError`s if state creation fails.
    func setupDepthStencil() {
        let depthDescriptor = MTLDepthStencilDescriptor()
        depthDescriptor.label = "Tetrahedron Depth Testing"
        // Fragments pass the depth test if their depth value is less than the value already in the buffer.
        depthDescriptor.depthCompareFunction = .less
        // Allow passing fragments to write their depth value into the depth buffer.
        depthDescriptor.isDepthWriteEnabled = true
        
        // Create the immutable depth/stencil state object.
        guard let state = device.makeDepthStencilState(descriptor: depthDescriptor) else {
            fatalError("Failed to create depth stencil state")
        }
        depthState = state
    }

    // MARK: Per-Frame Update
    
    /// Calculates the Model-View-Projection (MVP) matrix based on the current rotation angle and aspect ratio.
    /// Updates the contents of the `uniformBuffer` with the new matrix.
    /// Increments the `rotationAngle` for the next frame's animation.
    func updateUniforms() {
        // --- Projection Matrix ---
        // Defines the viewing frustum (how the 3D scene is projected onto the 2D screen).
        // Uses a left-handed coordinate system perspective projection.
        let projectionMatrix = matrix_perspective_left_hand(
            fovyRadians: .pi / 3.0,   // Field of view angle (vertical)
            aspectRatio: aspectRatio, // Width / Height ratio of the view
            nearZ: 0.1,              // Distance to the near clipping plane
            farZ: 100.0              // Distance to the far clipping plane
        )

        // --- View Matrix ---
        // Defines the camera's position and orientation in the world.
        // Uses a left-handed look-at matrix.
        let viewMatrix = matrix_look_at_left_hand(
            eye: SIMD3<Float>(0, 0.5, -4), // Camera position (slightly above, back from origin)
            center: SIMD3<Float>(0, 0, 0), // Point the camera is looking at (the origin)
            up: SIMD3<Float>(0, 1, 0)      // World's up direction (positive Y)
        )

        // --- Model Matrix ---
        // Transforms the model from its local space to world space.
        // Apply rotations for animation. Combine Y and X rotations.
        let rotationY = matrix_rotation_y(radians: rotationAngle)
        let rotationX = matrix_rotation_x(radians: rotationAngle * 0.5) // Rotate slightly slower on X
        let modelMatrix = matrix_multiply(rotationY, rotationX) // Combine rotations (order matters)

        // --- Combine Matrices: MVP = Projection * View * Model ---
        // Order is important: transforms vertex from model -> world -> view -> clip space.
        let modelViewMatrix = matrix_multiply(viewMatrix, modelMatrix) // V * M
        let mvpMatrix = matrix_multiply(projectionMatrix, modelViewMatrix) // P * (V * M)
        
        // --- Upload to GPU Buffer ---
        // Create the Uniforms struct with the calculated MVP matrix.
        var uniforms = Uniforms(modelViewProjectionMatrix: mvpMatrix)
        // Get a pointer to the uniform buffer's memory and copy the new uniform data into it.
        uniformBuffer.contents().copyMemory(from: &uniforms, byteCount: MemoryLayout<Uniforms>.stride)
        
        // --- Update Animation State ---
        // Increment the rotation angle for the next frame. Add a small amount to rotate slowly.
        rotationAngle += 0.01
        // (Wrap angle if desired, e.g., rotationAngle.formTruncatingRemainder(dividingBy: .pi * 2))
    }

    // MARK: - MTKViewDelegate Methods

    /// Called when the `MTKView`'s drawable size (resolution) changes, typically due to orientation change or window resize.
    /// Updates the `aspectRatio` property used in the projection matrix calculation.
    /// - Parameters:
    ///   - view: The `MTKView` whose size changed.
    ///   - size: The new drawable size in pixels.
    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {
        // Calculate the new aspect ratio (width / height). Use max(1, ...) to avoid division by zero if height is 0 briefly during resize.
        aspectRatio = Float(size.width / max(1, size.height))
        print("TetrahedronView Resized - New Aspect Ratio: \(aspectRatio)")
    }

    /// Called for each frame that needs to be rendered.
    /// This is the main rendering loop where commands are encoded and sent to the GPU.
    /// - Parameter view: The `MTKView` requesting the drawing update.
    func draw(in view: MTKView) {
        // --- Obtain Required Metal Objects ---
        // Ensure we have a drawable (texture to render into), a render pass descriptor (describes render targets),
        // a command buffer (holds encoded commands), and a render encoder (writes commands into the buffer).
        guard let drawable = view.currentDrawable,
              let renderPassDescriptor = view.currentRenderPassDescriptor,
              let commandBuffer = commandQueue.makeCommandBuffer(),
              // Create the render command encoder using the view's descriptor (configures clear colors, load/store actions, etc.).
              let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor) else {
            print("Metal setup failed in tetrahedron draw(in:). Required objects not available. Skipping frame.")
            return // Cannot proceed with rendering this frame
        }

        // --- Update Dynamic Data ---
        // Calculate the latest MVP matrix and upload it to the uniform buffer.
        updateUniforms()

        // --- Configure Render Encoder ---
        renderEncoder.label = "Tetrahedron Render Encoder" // Debug label
        // Set the compiled pipeline state object for this draw call.
        renderEncoder.setRenderPipelineState(pipelineState)
        // Set the depth testing state.
        renderEncoder.setDepthStencilState(depthState)
        // Set face culling mode (optional, could cull back faces: .back)
        // renderEncoder.setCullMode(.back)

        // *** Set Render Mode to Wireframe ***
        // This tells the rasterizer to draw lines connecting triangle vertices instead of filling triangles.
        renderEncoder.setTriangleFillMode(.lines)

        // --- Bind Buffers to Shader Arguments ---
        // Bind the vertex buffer to the [[buffer(0)]] argument in the vertex shader.
        renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, index: 0)
        // Bind the uniform buffer to the [[buffer(1)]] argument in the vertex shader.
        renderEncoder.setVertexBuffer(uniformBuffer, offset: 0, index: 1)

        // --- Issue Draw Call ---
        // Instruct the GPU to draw indexed triangles.
        renderEncoder.drawIndexedPrimitives(type: .triangle,         // Primitive type
                                            indexCount: indices.count, // Number of indices (12 for tetrahedron)
                                            indexType: .uint16,       // Data type of indices
                                            indexBuffer: indexBuffer,  // Buffer containing indices
                                            indexBufferOffset: 0)     // Offset into the index buffer

        // --- Finalize Rendering ---
        // Signal that command encoding for this render pass is complete.
        renderEncoder.endEncoding()
        
        // Schedule the drawable to be presented onscreen after the command buffer completes execution.
        commandBuffer.present(drawable)
        
        // Commit the command buffer to the command queue, sending it to the GPU for execution.
        commandBuffer.commit()
    }
}

// MARK: - SwiftUI UIViewRepresentable

/// A SwiftUI view that wraps the `MTKView` and its associated `TetrahedronRenderer` (via the Coordinator).
/// This acts as the bridge between the UIKit-based `MTKView` and the SwiftUI view hierarchy.
struct MetalTetrahedronViewRepresentable: UIViewRepresentable {
    /// Specifies the UIKit view type being represented (`MTKView`).
    typealias UIViewType = MTKView

    /// Creates and returns the `TetrahedronRenderer` instance, which acts as the Coordinator.
    /// The Coordinator manages the state and serves as the delegate for the `MTKView`.
    /// - Parameter context: The context provided by SwiftUI.
    /// - Returns: The initialized `TetrahedronRenderer`.
    /// - Note: `fatalError`s if the Metal device or renderer cannot be created.
    func makeCoordinator() -> TetrahedronRenderer {
        // Get the default system Metal device (GPU).
        guard let device = MTLCreateSystemDefaultDevice() else {
            fatalError("Metal is not supported on this device.")
        }
        // Initialize the custom renderer class.
        guard let coordinator = TetrahedronRenderer(device: device) else {
            fatalError("TetrahedronRenderer failed to initialize.")
        }
        print("Coordinator (TetrahedronRenderer) created.")
        return coordinator
    }

    /// Creates the underlying `MTKView` instance and configures it for Metal rendering.
    /// Sets up the device, frame rate, pixel formats, clear color/depth, and assigns the Coordinator as the delegate.
    /// - Parameter context: The context containing the Coordinator.
    /// - Returns: The configured `MTKView`.
    func makeUIView(context: Context) -> MTKView {
        let mtkView = MTKView()
        mtkView.device = context.coordinator.device // Assign the Metal device
        mtkView.preferredFramesPerSecond = 60       // Target frame rate
        mtkView.enableSetNeedsDisplay = false       // Use delegate-driven drawing loop
        
        // --- Configure Buffers ---
        mtkView.depthStencilPixelFormat = .depth32Float // Request a 32-bit depth buffer
        mtkView.colorPixelFormat = .bgra8Unorm_srgb    // Standard color format, sRGB ensures correct color appearance
        
        // --- Configure Clearing ---
        mtkView.clearDepth = 1.0 // Value to clear depth buffer with (1.0 is farthest)
        // Set background color (slightly different from Octahedron example for distinction)
        mtkView.clearColor = MTLClearColor(red: 0.1, green: 0.15, blue: 0.1, alpha: 1.0)

        // --- Configure Renderer & Delegate ---
        // Allow the renderer (Coordinator) to set up its pipeline based on the view's formats.
        context.coordinator.configure(metalKitView: mtkView)
        
        // Set the Coordinator as the MTKView's delegate AFTER configuration.
        // The delegate's draw(in:) method will now be called automatically each frame.
        mtkView.delegate = context.coordinator

        // --- Initial Size ---
        // Manually trigger the size update once initially to set the correct aspect ratio.
        context.coordinator.mtkView(mtkView, drawableSizeWillChange: mtkView.drawableSize)
        
        print("MTKView created and configured for Tetrahedron.")
        return mtkView
    }

    /// Updates the `MTKView` when SwiftUI state changes.
    /// Not used in this example as the animation is driven internally by the `TetrahedronRenderer`.
    /// - Parameters:
    ///   - uiView: The `MTKView` instance.
    ///   - context: The context containing the Coordinator and environment information.
    func updateUIView(_ uiView: MTKView, context: Context) {
        // No external SwiftUI state drives changes لهذا View in this example.
        // If, for example, rotation speed were a @State variable in the parent SwiftUI view,
        // you would update the coordinator's rotation speed property here.
    }
}

// MARK: - Main SwiftUI View

/// The main SwiftUI `View` that displays the title and embeds the Metal-rendered tetrahedron.
struct TetrahedronView: View {
    var body: some View {
        VStack(spacing: 0) { // Use zero spacing for seamless integration
            // --- Title Bar ---
            Text("Rotating Wireframe Tetrahedron (Metal)")
                .font(.headline)
                .padding()
                .frame(maxWidth: .infinity) // Span full width
                .background(Color(red: 0.1, green: 0.15, blue: 0.1)) // Match MTKView clear color
                .foregroundColor(.white)

            // --- Metal View Container ---
            // Embed the UIViewRepresentable wrapper for the MTKView.
            MetalTetrahedronViewRepresentable()
                // Optional: Uncomment to allow the Metal view to extend into safe areas.
                // .ignoresSafeArea()
        }
        // Set background for the entire VStack area, matching the Metal view's clear color.
        .background(Color(red: 0.1, green: 0.15, blue: 0.1))
        // Prevent keyboard presentation from pushing the view up (useful if text fields were added).
        .ignoresSafeArea(.keyboard)
    }
}

// MARK: - Preview Provider

/// Provides previews for the `TetrahedronView` in Xcode.
#Preview {
    
    // Option 1: Use a Placeholder View (Generally Safer & Faster for Previews)
    // Metal views often don't render perfectly or reliably in Xcode Previews.
    // A placeholder avoids potential issues and indicates where the Metal content will be.
    struct PreviewPlaceholder: View {
        var body: some View {
            VStack {
                Text("Rotating Wireframe Tetrahedron (Metal)")
                    .font(.headline).padding().foregroundColor(.white)
                Spacer()
                Text("Metal View Placeholder\n(Run on Simulator or Device for actual rendering)")
                    .foregroundColor(.gray)
                    .italic()
                    .multilineTextAlignment(.center)
                    .padding()
                Spacer()
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .background(Color(red: 0.1, green: 0.15, blue: 0.1)) // Match expected background
            .edgesIgnoringSafeArea(.all) // Fill entire preview area
        }
    }
    // return PreviewPlaceholder() // --- UNCOMMENT THIS LINE to use the placeholder preview by default ---

    // Option 2: Attempt to Render the Actual Metal View in Preview
    // This might work on some systems/Xcode versions but can be unreliable or slow.
    return TetrahedronView() // --- COMMENT OUT 'PreviewPlaceholder' above and UNCOMMENT THIS LINE to try actual rendering ---
}

// MARK: - Matrix Math Helper Functions (using SIMD - Left-Handed)
// (Generic 3D graphics math utility functions, suitable for left-handed coordinate systems)

/// Creates a perspective projection matrix using a left-handed coordinate system.
/// Transforms view space coordinates into clip space coordinates.
/// - Parameters:
///   - fovyRadians: The vertical field of view angle in radians.
///   - aspectRatio: The aspect ratio of the viewport (width / height).
///   - nearZ: The distance to the near clipping plane. Must be positive.
///   - farZ: The distance to the far clipping plane. Must be greater than nearZ.
/// - Returns: A 4x4 perspective projection matrix (`matrix_float4x4`).
func matrix_perspective_left_hand(fovyRadians: Float, aspectRatio: Float, nearZ: Float, farZ: Float) -> matrix_float4x4 {
    let y_scale = 1.0 / tan(fovyRadians * 0.5)
    let x_scale = y_scale / aspectRatio
    let z_scale = farZ / (farZ - nearZ) // For LH projection
    
    // Construct the matrix columns
    let P = matrix_float4x4(
        SIMD4<Float>(x_scale, 0, 0, 0),        // Column 0
        SIMD4<Float>(0, y_scale, 0, 0),        // Column 1
        SIMD4<Float>(0, 0, z_scale, 1),        // Column 2 (Note the '1' for LH perspective divide)
        SIMD4<Float>(0, 0, -nearZ * z_scale, 0) // Column 3
    )
    return P
}

/// Creates a view matrix for a left-handed coordinate system based on camera position, target, and up direction.
/// Transforms world space coordinates into view (camera) space coordinates.
/// - Parameters:
///   - eye: The position of the camera (the "eye") in world space.
///   - center: The point in world space that the camera is looking at.
///   - up: The vector indicating the "up" direction in world space (usually (0, 1, 0)).
/// - Returns: A 4x4 view transformation matrix (`matrix_float4x4`).
func matrix_look_at_left_hand(eye: SIMD3<Float>, center: SIMD3<Float>, up: SIMD3<Float>) -> matrix_float4x4 {
    // Calculate the camera's local coordinate axes (forward, right, up)
    let zAxis = normalize(center - eye) // Forward direction (Points from eye to center)
    let xAxis = normalize(cross(up, zAxis)) // Right direction (Perpendicular to up and forward)
    let yAxis = cross(zAxis, xAxis) // Camera's up direction (Perpendicular to forward and right)

    // Calculate the translation components (negative dot products)
    let translateX = -dot(xAxis, eye)
    let translateY = -dot(yAxis, eye)
    let translateZ = -dot(zAxis, eye)

    // Construct the view matrix (transposed rotation matrix combined with translation)
    // Rows of the matrix store the camera's axes and the translation
    let V = matrix_float4x4(
        SIMD4<Float>(xAxis.x,  yAxis.x,  zAxis.x, 0), // Column 0
        SIMD4<Float>(xAxis.y,  yAxis.y,  zAxis.y, 0), // Column 1
        SIMD4<Float>(xAxis.z,  yAxis.z,  zAxis.z, 0), // Column 2
        SIMD4<Float>(translateX, translateY, translateZ, 1)  // Column 3
    )
    return V
}

/// Creates a 4x4 rotation matrix for rotation around the Y-axis (yaw).
/// - Parameter radians: The rotation angle in radians.
/// - Returns: A Y-axis rotation matrix.
func matrix_rotation_y(radians: Float) -> matrix_float4x4 {
    let c = cos(radians)
    let s = sin(radians)
    // Matrix columns for Y rotation
    return matrix_float4x4(
        SIMD4<Float>( c, 0, s, 0), // Column 0
        SIMD4<Float>( 0, 1, 0, 0), // Column 1
        SIMD4<Float>(-s, 0, c, 0), // Column 2
        SIMD4<Float>( 0, 0, 0, 1)  // Column 3
    )
}

/// Creates a 4x4 rotation matrix for rotation around the X-axis (pitch).
/// - Parameter radians: The rotation angle in radians.
/// - Returns: An X-axis rotation matrix.
func matrix_rotation_x(radians: Float) -> matrix_float4x4 {
    let c = cos(radians)
    let s = sin(radians)
    // Matrix columns for X rotation
    return matrix_float4x4(
        SIMD4<Float>(1,  0, 0, 0), // Column 0
        SIMD4<Float>(0,  c, s, 0), // Column 1
        SIMD4<Float>(0, -s, c, 0), // Column 2
        SIMD4<Float>(0,  0, 0, 1)  // Column 3
    )
}

/// Multiplies two 4x4 matrices using SIMD's built-in multiplication operator.
/// Matrix multiplication is not commutative (order matters: A * B != B * A).
/// - Parameters:
///   - matrix1: The left-hand side matrix.
///   - matrix2: The right-hand side matrix.
/// - Returns: The resulting matrix product (`matrix1 * matrix2`).
func matrix_multiply(_ matrix1: matrix_float4x4, _ matrix2: matrix_float4x4) -> matrix_float4x4 {
    // SIMD provides an overloaded '*' operator for matrix multiplication.
    return matrix1 * matrix2
}
