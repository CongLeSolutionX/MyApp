//
//  AncientMemoriesView_V4.swift
//  MyApp
//
//  Created by Cong Le on 5/4/25.
//

//
//  FlowerOfLifeView.swift
//  MyApp // Example App Name
//
//  Created by Cong Le on 5/4/25. // Adapted Creation Date
//  Generated by AI based on user request and reference code. Optimized for Geometry.
//
//  Description:
//  Optimized version attempting to more closely match the geometric structure
//  of the provided image using Metal line rendering within SwiftUI.
//  Focuses on calculating intersections and drawing specific arcs.
//  NOTE: Does NOT replicate filled areas, gradients, or glow effects from the image,
//        as those require fundamentally different rendering techniques (triangles, post-processing).
//
//  Copyright (c) 2025 Cong Le. All Rights Reserved.
//  License(s): MIT, CC BY 4.0 (based on user's markdown diagrams)
//
import SwiftUI
import MetalKit
import simd

// MARK: - Metal Shaders (Embedded String) - Unchanged from previous line example
let flowerMetalShaderSource = """
#include <metal_stdlib>
using namespace metal;

struct VertexIn {
    float3 position [[attribute(0)]];
    float4 color    [[attribute(1)]];
};

struct VertexOut {
    float4 position [[position]];
    float4 color;
};

struct Uniforms {
    float4x4 modelViewProjectionMatrix;
};

vertex VertexOut flower_vertex_shader(
    const device VertexIn *vertices [[buffer(0)]],
    const device Uniforms &uniforms [[buffer(1)]],
    unsigned int vid [[vertex_id]]
) {
    VertexOut out;
    VertexIn currentVertex = vertices[vid];
    out.position = uniforms.modelViewProjectionMatrix * float4(currentVertex.position, 1.0);
    out.color = currentVertex.color;
    return out;
}

fragment half4 flower_fragment_shader( VertexOut in [[stage_in]] ) {
    // Basic fragment shader for lines. Glow/complex effects require post-processing.
    return half4(in.color);
}
"""

// MARK: - Swift Data Structures
struct Uniforms {
    var modelViewProjectionMatrix: matrix_float4x4
}

struct FlowerVertex {
    var position: SIMD3<Float>
    var color: SIMD4<Float>
}

// MARK: - Renderer Class
class FlowerRenderer: NSObject, MTKViewDelegate {

    let device: MTLDevice
    let commandQueue: MTLCommandQueue
    var pipelineState: MTLRenderPipelineState!
    var depthState: MTLDepthStencilState!

    var vertexBuffer: MTLBuffer!
    var uniformBuffer: MTLBuffer!
    var lineVertices: [FlowerVertex] = []

    // --- Geometry Configuration ---
    let primaryRadius: Float = 0.5          // Radius of the main circles
    let numArcSegments: Int = 24            // Segments per arc for smoothness
    let lineColor = SIMD4<Float>(0.1, 1.0, 0.4, 1.0) // Vibrant Green
    let center = SIMD3<Float>(0, 0, 0)    // Pattern center

    // Precomputed angles for 6-fold symmetry
    let symmetryAngles: [Float] = (0..<6).map { Float($0) * .pi / 3.0 } // 0, 60, 120... deg

    var aspectRatio: Float = 1.0

    init?(device: MTLDevice) {
        self.device = device
        guard let queue = device.makeCommandQueue() else { return nil }
        self.commandQueue = queue
        super.init()

        print("Generating geometry...")
        setupGeometry()     // Generate the line vertices based on intersections
        print("Geometry generated: \(lineVertices.count / 2) lines, \(lineVertices.count) vertices.")

        setupDepthStencil() // Setup depth testing
        setupBuffers()      // Create GPU buffers
    }

    func configure(metalKitView: MTKView) {
        setupPipeline(metalKitView: metalKitView)
    }

    // --- Geometry Generation ---

    /// Calculate intersection points of two circles.
    /// Returns an array of 0, 1, or 2 intersection points.
    func circleIntersections(center1: SIMD2<Float>, r1: Float, center2: SIMD2<Float>, r2: Float) -> [SIMD2<Float>] {
        let dVec = center2 - center1
        let d = length(dVec) // Distance between centers

        // Check for no intersection or containment
        if d > r1 + r2 || d < abs(r1 - r2) || d == 0 {
            return []
        }

        // Formula derived from law of cosines / geometry
        let a = (r1*r1 - r2*r2 + d*d) / (2 * d)
        let h = sqrt(max(0, r1*r1 - a*a)) // Use max(0,...) for stability near tangent

        let p2x = center1.x + a * dVec.x / d
        let p2y = center1.y + a * dVec.y / d
        let p2 = SIMD2<Float>(p2x, p2y)

        // Calculate the two intersection points
        let p3x_offset = h * dVec.y / d
        let p3y_offset = h * dVec.x / d

        let intersection1 = SIMD2<Float>(p2.x + p3x_offset, p2.y - p3y_offset)
        let intersection2 = SIMD2<Float>(p2.x - p3x_offset, p2.y + p3y_offset)

        if distance(intersection1, intersection2) < 1e-5 { // Handle tangent case
           return [intersection1]
        }

        return [intersection1, intersection2]
    }

    /// Creates line segments approximating an arc between two angles.
    func addArcLineSegments(arcCenter: SIMD3<Float>, radius: Float, startAngle: Float, endAngle: Float, segments: Int) {
        let angleStep = (endAngle - startAngle) / Float(segments)
        var lastPoint = SIMD3<Float>(
            arcCenter.x + radius * cos(startAngle),
            arcCenter.y + radius * sin(startAngle),
            arcCenter.z
        )

        for i in 1...segments {
            let angle = startAngle + Float(i) * angleStep
            let currentPoint = SIMD3<Float>(
                arcCenter.x + radius * cos(angle),
                arcCenter.y + radius * sin(angle),
                arcCenter.z
            )
            lineVertices.append(FlowerVertex(position: lastPoint, color: lineColor))
            lineVertices.append(FlowerVertex(position: currentPoint, color: lineColor))
            lastPoint = currentPoint
        }
    }

    /// Generates the line vertex data for the flower pattern using intersections.
    func setupGeometry() {
        lineVertices.removeAll()
        let R = primaryRadius

        // 1. Define the 7 primary circle centers (center + 6 surrounding)
        var centers: [SIMD3<Float>] = [center]
        for angle in symmetryAngles {
            centers.append(SIMD3<Float>(center.x + R * cos(angle), center.y + R * sin(angle), 0))
        }

        // 2. Draw the Vesica Piscis / Petal arcs for the central flower
        // Iterate through each surrounding circle and find intersections with the central one
        for i in 1...6 { // Index 0 is the central circle
            let center_i = centers[i]
            let intersections = circleIntersections(center1: SIMD2(center.x, center.y), r1: R,
                                                 center2: SIMD2(center_i.x, center_i.y), r2: R)

            if intersections.count == 2 {
                // Find angles of intersection points relative to the *current* circle's center (center_i)
                let p1 = intersections[0]
                let p2 = intersections[1]
                var angle1 = atan2(p1.y - center_i.y, p1.x - center_i.x)
                var angle2 = atan2(p2.y - center_i.y, p2.x - center_i.x)

                // Ensure angles are in correct order (e.g., handle wraparound)
                // We want the outer arc of the surrounding circle cut by the central circle
                let centerVecAngle = atan2(center.y - center_i.y, center.x - center_i.x)

                // Adjust angles to be relative to the vector pointing towards the center
                angle1 -= centerVecAngle
                angle2 -= centerVecAngle

                // Normalize angles to -pi to pi
                 while angle1 > .pi { angle1 -= 2 * .pi }
                 while angle1 <= -.pi { angle1 += 2 * .pi }
                 while angle2 > .pi { angle2 -= 2 * .pi }
                 while angle2 <= -.pi { angle2 += 2 * .pi }

                // Find the angle range that points *away* from the center circle
                let startAngle, endAngle: Float
                // Usually, the outer arc is between ~ -120 and +120 deg relative to centerVecAngle
                if angle1 < angle2  {
                    startAngle = angle2 + centerVecAngle
                    endAngle = angle1 + centerVecAngle + 2 * .pi // Go the long way around
                 } else {
                    startAngle = angle1 + centerVecAngle
                    endAngle = angle2 + centerVecAngle + 2 * .pi // Go the long way around
                 }

                addArcLineSegments(arcCenter: center_i, radius: R, startAngle: startAngle, endAngle: endAngle, segments: numArcSegments * 2 / 3) // Use fewer segments for partial arc

                // Also draw the corresponding inner arc of the *central* circle cut by this surrounding circle
                 let center_angle1 = atan2(p1.y - center.y, p1.x - center.x)
                 let center_angle2 = atan2(p2.y - center.y, p2.x - center.x)

                 // Ensure angles order
                 var startAngleC = center_angle1
                 var endAngleC = center_angle2
                 if abs(normalizeAngle(startAngleC - endAngleC)) > .pi { // Choose the shorter arc
                       if startAngleC < endAngleC { startAngleC += 2 * .pi }
                       else { endAngleC += 2 * .pi }
                 }
                 if startAngleC > endAngleC { swap(&startAngleC, &endAngleC) }

                addArcLineSegments(arcCenter: center, radius: R, startAngle: startAngleC, endAngle: endAngleC, segments: numArcSegments / 3)
            }
        }

       // 3. Add the central triangle (approximated)
       // Determine vertices based on the inner intersections or geometrically
        let triRadius = R * sqrt(3.0) / 2.0 * 0.9 // Slightly smaller than true intersection points
        let triAngleOffset: Float = .pi / 2.0 // Pointing up
        let triV1 = SIMD3<Float>(center.x + triRadius * cos(triAngleOffset), center.y + triRadius * sin(triAngleOffset), 0)
        let triV2 = SIMD3<Float>(center.x + triRadius * cos(triAngleOffset + 2 * .pi / 3), center.y + triRadius * sin(triAngleOffset + 2 * .pi / 3), 0)
        let triV3 = SIMD3<Float>(center.x + triRadius * cos(triAngleOffset + 4 * .pi / 3), center.y + triRadius * sin(triAngleOffset + 4 * .pi / 3), 0)

        lineVertices.append(contentsOf: [
            FlowerVertex(position: triV1, color: lineColor), FlowerVertex(position: triV2, color: lineColor),
            FlowerVertex(position: triV2, color: lineColor), FlowerVertex(position: triV3, color: lineColor),
            FlowerVertex(position: triV3, color: lineColor), FlowerVertex(position: triV1, color: lineColor)
        ])

         // 4. (Optional) Add outer circles/arcs
         // This requires calculating intersections between the surrounding circles themselves,
         // which adds significant complexity. For this example, we'll stop at the core flower.
         // To add the outer boundary like the image, you'd draw larger arcs or full circles.
         
         // Example: Outer bounding circle (similar to image's purple circle)
         // let outerBoundRadius = R * 2.0 // Radius encompassing the first layer
         // addArcLineSegments(arcCenter: center, radius: outerBoundRadius, startAngle: 0, endAngle: 2 * .pi, segments: numArcSegments * 3)

    }

    /// Helper to normalize angle to -pi to pi range
    func normalizeAngle(_ angle: Float) -> Float {
        var result = angle
        while result <= -.pi { result += 2 * .pi }
        while result > .pi { result -= 2 * .pi }
        return result
    }

    /// Compiles shaders and creates the `MTLRenderPipelineState`.
    func setupPipeline(metalKitView: MTKView) {
         // (Identical to previous line example - create library, functions, descriptor, vertexDescriptor, state)
         // ... (ensure shader names match: flower_vertex_shader, flower_fragment_shader)
        do {
            let library = try device.makeLibrary(source: flowerMetalShaderSource, options: nil)
            guard let vertexFunction = library.makeFunction(name: "flower_vertex_shader"),
                  let fragmentFunction = library.makeFunction(name: "flower_fragment_shader") else {
                fatalError("Could not load shader functions.")
            }

            let pipelineDescriptor = MTLRenderPipelineDescriptor()
            pipelineDescriptor.label = "Flower Optimized Line Pipeline"
            pipelineDescriptor.vertexFunction = vertexFunction
            pipelineDescriptor.fragmentFunction = fragmentFunction
            pipelineDescriptor.colorAttachments[0].pixelFormat = metalKitView.colorPixelFormat
            pipelineDescriptor.depthAttachmentPixelFormat = metalKitView.depthStencilPixelFormat // Keep depth

            let vertexDescriptor = MTLVertexDescriptor()
            vertexDescriptor.attributes[0].format = .float3 // Position
            vertexDescriptor.attributes[0].offset = 0
            vertexDescriptor.attributes[0].bufferIndex = 0
            vertexDescriptor.attributes[1].format = .float4 // Color
            vertexDescriptor.attributes[1].offset = MemoryLayout<SIMD3<Float>>.stride
            vertexDescriptor.attributes[1].bufferIndex = 0
            vertexDescriptor.layouts[0].stride = MemoryLayout<FlowerVertex>.stride
            vertexDescriptor.layouts[0].stepFunction = .perVertex
            pipelineDescriptor.vertexDescriptor = vertexDescriptor

             // Note on line width: Metal doesn't have a standard cross-platform way
             // to set line width > 1px directly in the pipeline state easily.
             // Achieving thicker lines often requires rendering triangles (strips).

            pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)

        } catch {
            fatalError("Failed to create Metal Render Pipeline State: \(error)")
        }
    }

    /// Creates and populates the GPU buffers for vertices and uniforms.
    func setupBuffers() {
         // (Identical to previous line example - create vertex and uniform buffers)
        guard !lineVertices.isEmpty else {
             print("Warning: Line vertices array empty. Creating placeholder buffers.")
             vertexBuffer = device.makeBuffer(length: MemoryLayout<FlowerVertex>.stride, options: [])!
             vertexBuffer.label = "Empty Vertex Buffer Placeholder"
             uniformBuffer = device.makeBuffer(length: MemoryLayout<Uniforms>.size, options: .storageModeShared)!
             uniformBuffer.label = "Uniform Buffer"
             return
        }

        let vertexDataSize = lineVertices.count * MemoryLayout<FlowerVertex>.stride
        guard let vBuffer = device.makeBuffer(bytes: lineVertices, length: vertexDataSize, options: []) else {
            fatalError("Could not create vertex buffer")
        }
        vertexBuffer = vBuffer
        vertexBuffer.label = "Flower Line Vertices (Optimized)"

        let uniformBufferSize = MemoryLayout<Uniforms>.size
        guard let uBuffer = device.makeBuffer(length: uniformBufferSize, options: .storageModeShared) else {
            fatalError("Could not create uniform buffer")
        }
        uniformBuffer = uBuffer
        uniformBuffer.label = "Uniforms Buffer (MVP)"
    }

    /// Creates the `MTLDepthStencilState` object.
    func setupDepthStencil() {
        // (Identical to previous example)
        let depthDescriptor = MTLDepthStencilDescriptor()
        depthDescriptor.depthCompareFunction = .less
        depthDescriptor.isDepthWriteEnabled = true
        guard let state = device.makeDepthStencilState(descriptor: depthDescriptor) else {
            fatalError("Failed to create depth stencil state")
        }
        depthState = state
    }

    // --- Update State Per Frame ---
    func updateUniforms() {
        // Static view for better pattern visibility
        let projectionMatrix = matrix_perspective_left_hand(
            fovyRadians: Float.pi / 3.0, // Adjust FOV for desired zoom
            aspectRatio: aspectRatio,
            nearZ: 0.1,
            farZ: 100.0
        )

        // Position camera head-on, slightly back
        let viewMatrix = matrix_look_at_left_hand(
            eye: SIMD3<Float>(0, 0, -3.0 * primaryRadius * 2.5), // Adjust Z based on pattern size
            center: center, // Look directly at the center
            up: SIMD3<Float>(0, 1, 0)
        )

        // No rotation - Model matrix is identity
        let modelMatrix = matrix_identity_float4x4

        // Combine: MVP = Projection * View * Model
        let mvpMatrix = matrix_multiply(projectionMatrix, matrix_multiply(viewMatrix, modelMatrix)) // P * V * M

        // Update Uniform Buffer
        var uniforms = Uniforms(modelViewProjectionMatrix: mvpMatrix)
        memcpy(uniformBuffer.contents(), &uniforms, MemoryLayout<Uniforms>.size)
    }

    // MARK: - MTKViewDelegate Methods
    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {
        // (Identical - update aspect ratio)
        aspectRatio = Float(size.width / max(1, size.height))
    }

    func draw(in view: MTKView) {
        // (Identical draw loop structure, ensuring vertexCount is correct for lines)
        guard let drawable = view.currentDrawable,
              let renderPassDescriptor = view.currentRenderPassDescriptor,
              let commandBuffer = commandQueue.makeCommandBuffer(),
              let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor) else {
            return // Skip frame if setup fails
        }

        // Guard against drawing with empty buffers
        guard vertexBuffer != nil, vertexBuffer.length > 0, lineVertices.count > 0 else {
           // print("Draw skipped: vertex buffer empty or invalid.")
            renderEncoder.endEncoding()
            commandBuffer.present(drawable)
            commandBuffer.commit()
            return
        }

        updateUniforms() // Update MVP matrix

        renderEncoder.label = "Flower Optimized Render Encoder"
        renderEncoder.setRenderPipelineState(pipelineState)
        renderEncoder.setDepthStencilState(depthState)

        renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, index: 0)
        renderEncoder.setVertexBuffer(uniformBuffer, offset: 0, index: 1)

        // Draw the lines
        renderEncoder.drawPrimitives(type: .line,
                                     vertexStart: 0,
                                     vertexCount: lineVertices.count) // Draw all generated vertices

        renderEncoder.endEncoding()
        commandBuffer.present(drawable)
        commandBuffer.commit()
    }
}

// MARK: - SwiftUI UIViewRepresentable (Flower Version)
struct MetalFlowerViewRepresentable: UIViewRepresentable {
    // (Structure identical to previous example, just uses FlowerRenderer)
    typealias UIViewType = MTKView

    func makeCoordinator() -> FlowerRenderer {
        guard let device = MTLCreateSystemDefaultDevice(),
              let coordinator = FlowerRenderer(device: device) else {
            fatalError("FlowerRenderer initialization failed.")
        }
        return coordinator
    }

    func makeUIView(context: Context) -> MTKView {
        let mtkView = MTKView()
        mtkView.device = context.coordinator.device
        mtkView.preferredFramesPerSecond = 60 // Can reduce if static (e.g., 30 or less)
        mtkView.enableSetNeedsDisplay = false // Use draw loop
        mtkView.depthStencilPixelFormat = .depth32Float
        mtkView.clearDepth = 1.0
        // Dark background closer to the target image's feel
        mtkView.clearColor = MTLClearColor(red: 0.02, green: 0.01, blue: 0.05, alpha: 1.0) // Very dark purple/black
        mtkView.colorPixelFormat = .bgra8Unorm_srgb

        context.coordinator.configure(metalKitView: mtkView)
        mtkView.delegate = context.coordinator
        context.coordinator.mtkView(mtkView, drawableSizeWillChange: mtkView.drawableSize)

        return mtkView
    }

    func updateUIView(_ uiView: MTKView, context: Context) { /* No external updates */ }
}

// MARK: - Main SwiftUI View (Flower Version)
struct FlowerOfLifeView: View {
    // (Identical structure to previous example)
    var body: some View {
        VStack(spacing: 0) {
             Text("Geometric Pattern (Metal Lines - Optimized Geometry)")
                .font(.caption) // Smaller title
                .padding(EdgeInsets(top: 4, leading: 10, bottom: 4, trailing: 10))
                .frame(maxWidth: .infinity)
                .background(Color(red: 0.02, green: 0.01, blue: 0.05)) // Match clear color
                .foregroundColor(.gray)

            MetalFlowerViewRepresentable()
        }
        .background(Color(red: 0.02, green: 0.01, blue: 0.05))
        .ignoresSafeArea(.all) // Fill entire screen
    }
}

// MARK: - Preview Provider
#Preview {
     // (Using placeholder is still recommended for Metal previews)
    struct PreviewPlaceholder: View {
        var body: some View {
             ZStack { // Use ZStack to overlay text on BG
                  Color(red: 0.02, green: 0.01, blue: 0.05).ignoresSafeArea()
                  VStack {
                      Text("Geometric Pattern (Metal Lines - Optimized Geometry)")
                           .font(.caption).foregroundColor(.gray)
                      Spacer()
                      Text("Metal View Placeholder\n(Run on Simulator or Device)")
                           .foregroundColor(.gray).italic().multilineTextAlignment(.center).padding()
                      Spacer()
                  }
             }
        }
    }
     return PreviewPlaceholder()
    // return FlowerOfLifeView() // Uncomment to attempt live preview
}

// MARK: - Matrix Math Helper Functions (Left-Handed)
// (Unchanged - Standard matrix functions)
func matrix_perspective_left_hand(fovyRadians: Float, aspectRatio: Float, nearZ: Float, farZ: Float) -> matrix_float4x4 { /* ... same implementation ... */
    let y = 1.0 / tan(fovyRadians * 0.5); let x = y / aspectRatio; let z = farZ / (farZ - nearZ); let w = -nearZ * z
    return matrix_float4x4(SIMD4(x,0,0,0), SIMD4(0,y,0,0), SIMD4(0,0,z,1), SIMD4(0,0,w,0))
}
func matrix_look_at_left_hand(eye: SIMD3<Float>, center: SIMD3<Float>, up: SIMD3<Float>) -> matrix_float4x4 { /* ... same implementation ... */
    let zAxis = normalize(center - eye); let xAxis = normalize(cross(up, zAxis)); let yAxis = cross(zAxis, xAxis)
    let tx = -dot(xAxis, eye); let ty = -dot(yAxis, eye); let tz = -dot(zAxis, eye)
    return matrix_float4x4( SIMD4(xAxis.x, yAxis.x, zAxis.x, 0), SIMD4(xAxis.y, yAxis.y, zAxis.y, 0), SIMD4(xAxis.z, yAxis.z, zAxis.z, 0), SIMD4(tx, ty, tz, 1))
}
let matrix_identity_float4x4 = matrix_float4x4(diagonal: SIMD4<Float>(1,1,1,1))
