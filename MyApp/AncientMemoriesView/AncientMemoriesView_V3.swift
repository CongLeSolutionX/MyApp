//
//  AncientMemoriesView_V3.swift
//  MyApp
//
//  Created by Cong Le on 5/4/25.
//

//
//  FlowerOfLifeView.swift
//  MyApp // Example App Name
//
//  Created by Cong Le on 5/4/25. // Adapted Creation Date
//  Generated by AI based on user request and reference code.
//
//  Description:
//  This file defines a SwiftUI view hierarchy that displays a 2D geometric pattern
//  resembling the "Flower of Life," rendered as lines using Apple's Metal framework.
//  It adapts the structure from a previous Octahedron example to showcase:
//  - Embedding a MetalKit view (MTKView) within SwiftUI using UIViewRepresentable.
//  - Procedural generation of 2D line geometry based on intersecting circles.
//  - Use of rotational symmetry to simplify geometry definition.
//  - A basic Metal rendering pipeline for lines (shaders, buffers, pipeline state).
//  - Usage of SIMD for matrix transformations (Model-View-Projection).
//  - Rendering line primitives.
//
//  Copyright (c) 2025 Cong Le. All Rights Reserved.
//  License(s): MIT, CC BY 4.0 (based on user's markdown diagrams)
//
import SwiftUI
import MetalKit // Provides MTKView and Metal integration helpers
import simd    // Provides efficient vector and matrix types/operations

// MARK: - Metal Shaders (Embedded String)

/// Contains the source code for the Metal vertex and fragment shaders.
/// These shaders run on the GPU to process vertices and determine pixel colors for the lines.
let flowerMetalShaderSource = """
#include <metal_stdlib> // Import the Metal Standard Library

using namespace metal; // Use the Metal namespace

// Structure defining vertex input data received from the CPU (Swift code).
// Layout MUST match 'FlowerVertex' struct and MTLVertexDescriptor.
struct VertexIn {
    // Vertex position in model space (x, y, z). z=0 for 2D patterns.
    float3 position [[attribute(0)]];
    // Vertex color (RGBA). Lines will take this color.
    float4 color    [[attribute(1)]];
};

// Structure defining data passed from the vertex shader to the fragment shader.
// Metal interpolates these values along the line segment.
struct VertexOut {
    // Final position in clip space (required output).
    float4 position [[position]];
    // Color to be interpolated for the fragment shad.
    float4 color;
};

// Structure for uniform data (constants for a draw call) passed from the CPU.
// MUST match the 'Uniforms' struct layout in Swift.
struct Uniforms {
    // Combined Model-View-Projection matrix.
    float4x4 modelViewProjectionMatrix;
};

// --- Vertex Shader ---
// Function executed for each vertex endpoint of the lines.
vertex VertexOut flower_vertex_shader(
    // Input: Array of vertices passed from the CPU's vertex buffer.
    // [[buffer(0)]] links to buffer bound at index 0.
    const device VertexIn *vertices [[buffer(0)]],
    // Input: Uniform data (MVP matrix) from the CPU's uniform buffer.
    // [[buffer(1)]] links to buffer bound at index 1.
    const device Uniforms &uniforms [[buffer(1)]],
    // Input: System-generated index of the current vertex being processed.
    unsigned int vid [[vertex_id]]
) {
    VertexOut out;
    VertexIn currentVertex = vertices[vid]; // Get data for this vertex endpoint

    // Calculate clip space position. Assume z=0 for input, add w=1.
    out.position = uniforms.modelViewProjectionMatrix * float4(currentVertex.position, 1.0);
    
    // Pass the vertex's color through.
    out.color = currentVertex.color;
    
    return out; // Return the processed vertex data
}

// --- Fragment Shader ---
// Function executed for each pixel fragment along the rasterized line segments.
fragment half4 flower_fragment_shader(
    // Input: Interpolated data received from the vertex shader.
    VertexOut in [[stage_in]]
) {
    // Return the interpolated color as the final color for this pixel on the line.
    return half4(in.color);
}
"""

// MARK: - Swift Data Structures (Matching Shaders)

/// Swift structure mirroring the layout of the 'Uniforms' struct in the Metal shader code.
struct Uniforms {
    /// The combined Model-View-Projection matrix.
    var modelViewProjectionMatrix: matrix_float4x4
}

/// Structure defining the layout of vertex data for the flower pattern lines.
/// Layout MUST match `VertexIn` struct in the shader and the `MTLVertexDescriptor`.
struct FlowerVertex {
    /// The 3D position (x, y, z) of the vertex endpoint. z is typically 0.
    var position: SIMD3<Float>
    /// The RGBA color associated with the vertex (used for the line color).
    var color: SIMD4<Float>
}

// MARK: - Renderer Class (Handles Metal Logic)

/// Manages Metal setup, resource creation, geometry generation, and rendering for the flower pattern.
/// Conforms to `MTKViewDelegate`.
class FlowerRenderer: NSObject, MTKViewDelegate {

    let device: MTLDevice
    let commandQueue: MTLCommandQueue
    var pipelineState: MTLRenderPipelineState!
    var depthState: MTLDepthStencilState! // Keep depth state even for 2D for potential layering

    /// GPU buffer holding the line endpoint vertex data (`FlowerVertex` array).
    var vertexBuffer: MTLBuffer!
    /// GPU buffer holding the transformation matrix (`Uniforms` struct).
    var uniformBuffer: MTLBuffer!

    /// Array holding pairs of vertices defining the line segments.
    /// Format: [start1, end1, start2, end2, ...]
    var lineVertices: [FlowerVertex] = []
    
    // Geometry constants
    let primaryRadius: Float = 0.5 // Base radius for the central circles
    let numArcSegments: Int = 30 // Number of line segments to approximate an arc
    let lineThickness: Float = 1.0 // Note: Metal line thickness is limited, often 1 pixel. Set via pipeline? Not directly standard.
    let lineColor = SIMD4<Float>(0.2, 1.0, 0.5, 1.0) // Bright green color for lines

    var rotationAngle: Float = 0.0
    var aspectRatio: Float = 1.0

    /// Initializes the renderer, command queue, depth state, geometry, and buffers.
    init?(device: MTLDevice) {
        self.device = device
        guard let queue = device.makeCommandQueue() else { return nil }
        self.commandQueue = queue
        super.init()

        setupDepthStencil() // Setup depth testing
        setupGeometry()     // Generate the line vertices
        setupBuffers()      // Create GPU buffers
    }

    /// Configures the Metal pipeline state after the MTKView is ready.
    func configure(metalKitView: MTKView) {
        setupPipeline(metalKitView: metalKitView)
    }

    // --- Helper Function for Arc Generation ---
    
    /// Creates an array of points approximating an arc.
    /// - Parameters:
    ///   - center: The center of the circle defining the arc.
    ///   - radius: The radius of the circle.
    ///   - startAngle: The starting angle of the arc in radians.
    ///   - endAngle: The ending angle of the arc in radians.
    ///   - segments: The number of line segments to use for approximation.
    /// - Returns: An array of SIMD3<Float> points along the arc.
    func createArcPoints(center: SIMD3<Float>, radius: Float, startAngle: Float, endAngle: Float, segments: Int) -> [SIMD3<Float>] {
        var points: [SIMD3<Float>] = []
        let angleStep = (endAngle - startAngle) / Float(segments)

        for i in 0...segments {
            let angle = startAngle + Float(i) * angleStep
            let x = center.x + radius * cos(angle)
            let y = center.y + radius * sin(angle)
            points.append(SIMD3<Float>(x, y, center.z)) // Assume z=0 for 2D pattern
        }
        return points
    }
    
    // --- Setup Functions ---

    /// Generates the line vertex data for the flower pattern.
    func setupGeometry() {
        lineVertices.removeAll() // Clear previous geometry if regenerating

        let center = SIMD3<Float>(0, 0, 0)
        let R = primaryRadius
        let pi = Float.pi

        // Define angles for 6-fold symmetry
        let angles = (0..<6).map { Float($0) * pi / 3.0 } // 0, 60, 120, 180, 240, 300 degrees

        // Function to add line segments from arc points
        func addArcSegments(points: [SIMD3<Float>]) {
            guard points.count > 1 else { return }
            for i in 0..<(points.count - 1) {
                lineVertices.append(FlowerVertex(position: points[i], color: lineColor))
                lineVertices.append(FlowerVertex(position: points[i+1], color: lineColor))
            }
        }
        
        // Generate the 6 surrounding circles (core of Seed/Flower of Life)
        for i in 0..<6 {
            let angle = angles[i]
            let circleCenter = SIMD3<Float>(center.x + R * cos(angle), center.y + R * sin(angle), 0)
            
            // Draw full circles for simplicity in this example
            // More complex: calculate intersection angles and draw specific arcs
            let circlePoints = createArcPoints(center: circleCenter, radius: R, startAngle: 0, endAngle: 2 * pi, segments: numArcSegments * 2) // Double segments for full circle
            addArcSegments(points: circlePoints)
        }

        // Optionally: Add the central circle
        let centralCirclePoints = createArcPoints(center: center, radius: R, startAngle: 0, endAngle: 2 * pi, segments: numArcSegments * 2)
        addArcSegments(points: centralCirclePoints)
        
        // Optionally: Add outer layer circles (gets more complex quickly)
        // Example: A layer based on radius 2*R
        let outerRadius = 2 * R
         for i in 0..<6 {
             let angle = angles[i]
             let circleCenter = SIMD3<Float>(center.x + outerRadius * cos(angle), center.y + outerRadius * sin(angle), 0)
             let circlePoints = createArcPoints(center: circleCenter, radius: R, startAngle: 0, endAngle: 2 * pi, segments: numArcSegments * 2)
             // You might only want specific arcs here based on intersections
             addArcSegments(points: circlePoints)
         }
         // Example: Outer bounding circle
         let boundingCirclePoints = createArcPoints(center: center, radius: R * 2 , startAngle: 0, endAngle: 2 * pi, segments: numArcSegments * 4) // Higher segments for larger circle
         addArcSegments(points: boundingCirclePoints)

        // Note: This geometry is a simplification. Replicating the *exact* intricate curves
        // and connections of the image requires much more complex geometric calculations
        // (finding analytical intersection points and angles for arcs) or using a different
        // approach like loading vector data or a texture. This code focuses on the core
        // structure of overlapping circles drawn with lines.
        
        print("Generated \(lineVertices.count / 2) line segments (\(lineVertices.count) vertices).")
    }

    /// Compiles shaders and creates the `MTLRenderPipelineState`.
    func setupPipeline(metalKitView: MTKView) {
        do {
            let library = try device.makeLibrary(source: flowerMetalShaderSource, options: nil)
            guard let vertexFunction = library.makeFunction(name: "flower_vertex_shader"),
                  let fragmentFunction = library.makeFunction(name: "flower_fragment_shader") else {
                fatalError("Could not load shader functions.")
            }

            let pipelineDescriptor = MTLRenderPipelineDescriptor()
            pipelineDescriptor.label = "Flower Line Pipeline"
            pipelineDescriptor.vertexFunction = vertexFunction
            pipelineDescriptor.fragmentFunction = fragmentFunction
            pipelineDescriptor.colorAttachments[0].pixelFormat = metalKitView.colorPixelFormat
            pipelineDescriptor.depthAttachmentPixelFormat = metalKitView.depthStencilPixelFormat

            let vertexDescriptor = MTLVertexDescriptor()
            // Attribute 0: Position (float3)
            vertexDescriptor.attributes[0].format = .float3
            vertexDescriptor.attributes[0].offset = 0
            vertexDescriptor.attributes[0].bufferIndex = 0
            // Attribute 1: Color (float4)
            vertexDescriptor.attributes[1].format = .float4
            vertexDescriptor.attributes[1].offset = MemoryLayout<SIMD3<Float>>.stride
            vertexDescriptor.attributes[1].bufferIndex = 0
            // Layout 0: Describes stride for FlowerVertex
            vertexDescriptor.layouts[0].stride = MemoryLayout<FlowerVertex>.stride
            vertexDescriptor.layouts[0].stepFunction = .perVertex

            pipelineDescriptor.vertexDescriptor = vertexDescriptor

            // Set line width if possible (Note: often clamped to 1.0 on mobile/Metal)
            // pipelineDescriptor.rasterizationEnabled = true // Ensure rasterization is on
            // Consider if lineWidth is available and settable here; maybe not standard on all devices.

            pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)

        } catch {
            fatalError("Failed to create Metal Render Pipeline State: \(error)")
        }
    }

    /// Creates and populates the GPU buffers for vertices and uniforms.
    func setupBuffers() {
        guard !lineVertices.isEmpty else {
             print("Warning: Line vertices array is empty. Nothing to draw.")
             // Create placeholder empty buffers to avoid crashes later
             vertexBuffer = device.makeBuffer(length: MemoryLayout<FlowerVertex>.stride, options: [])
             uniformBuffer = device.makeBuffer(length: MemoryLayout<Uniforms>.size, options: .storageModeShared)
             return
        }
        
        // --- Vertex Buffer ---
        let vertexDataSize = lineVertices.count * MemoryLayout<FlowerVertex>.stride
        guard let vBuffer = device.makeBuffer(bytes: lineVertices, length: vertexDataSize, options: []) else {
            fatalError("Could not create vertex buffer")
        }
        vertexBuffer = vBuffer
        vertexBuffer.label = "Flower Line Vertices"

        // --- Uniform Buffer ---
        let uniformBufferSize = MemoryLayout<Uniforms>.size
        guard let uBuffer = device.makeBuffer(length: uniformBufferSize, options: .storageModeShared) else {
            fatalError("Could not create uniform buffer")
        }
        uniformBuffer = uBuffer
        uniformBuffer.label = "Uniforms Buffer (MVP)"
    }

    /// Creates the `MTLDepthStencilState` object.
    func setupDepthStencil() {
        let depthDescriptor = MTLDepthStencilDescriptor()
        depthDescriptor.depthCompareFunction = .less // Standard depth test
        depthDescriptor.isDepthWriteEnabled = true   // Write closer fragments' depth
        guard let state = device.makeDepthStencilState(descriptor: depthDescriptor) else {
            fatalError("Failed to create depth stencil state")
        }
        depthState = state
    }

    // --- Update State Per Frame ---
    
    /// Calculates the Model-View-Projection (MVP) matrix and updates the uniform buffer.
    func updateUniforms() {
        let projectionMatrix = matrix_perspective_left_hand(
            fovyRadians: Float.pi / 2.5, // Wider FOV to see more of the 2D pattern
            aspectRatio: aspectRatio,
            nearZ: 0.1,
            farZ: 100.0
        )

        // Position camera slightly above origin, looking down, slightly back
        let viewMatrix = matrix_look_at_left_hand(
            eye: SIMD3<Float>(0, 0, -2.5), // Adjust Z to zoom in/out
            center: SIMD3<Float>(0, 0, 0), // Look at the center of the pattern
            up: SIMD3<Float>(0, 1, 0)      // Standard Y-up
        )

        // Apply rotation for visual interest (optional)
        let modelMatrix = matrix_rotation_z(radians: rotationAngle) // Rotate around Z if pattern is in XY
        // let modelMatrix = matrix_identity_float4x4 // Or keep static

        // Combine: MVP = Projection * View * Model
        let modelViewMatrix = matrix_multiply(viewMatrix, modelMatrix)
        let mvpMatrix = matrix_multiply(projectionMatrix, modelViewMatrix)

        // Update Uniform Buffer
        var uniforms = Uniforms(modelViewProjectionMatrix: mvpMatrix)
        memcpy(uniformBuffer.contents(), &uniforms, MemoryLayout<Uniforms>.size)
        
        // Animate (optional)
        // rotationAngle += 0.005 // Slower rotation might be better
    }

    // MARK: - MTKViewDelegate Methods

    /// Called when the MTKView's drawable size changes. Updates aspect ratio.
    func mtkView(_ view: MTKView, drawableSizeWillChange size: CGSize) {
        aspectRatio = Float(size.width / max(1, size.height))
        print("MTKView Resized - New Aspect Ratio: \(aspectRatio)")
    }

    /// Called for each frame to encode rendering commands.
    func draw(in view: MTKView) {
        guard let drawable = view.currentDrawable,
              let renderPassDescriptor = view.currentRenderPassDescriptor,
              let commandBuffer = commandQueue.makeCommandBuffer(),
              let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor) else {
            print("Failed to get required Metal objects in draw(in:). Skipping frame.")
            return
        }
        
        // Check if geometry exists
        guard let vBuffer = vertexBuffer, vBuffer.length > 0, lineVertices.count > 0 else {
            print("Skipping draw: Vertex buffer is not valid or empty.")
            renderEncoder.endEncoding() // Still need to end encoding
            commandBuffer.present(drawable) // Still need to present
            commandBuffer.commit() // Still need to commit
            return
        }

        updateUniforms() // Update MVP matrix

        renderEncoder.label = "Flower Render Encoder"
        renderEncoder.setRenderPipelineState(pipelineState)
        renderEncoder.setDepthStencilState(depthState)

        // Bind Buffers (No Index Buffer needed for drawing lines directly)
        renderEncoder.setVertexBuffer(vertexBuffer, offset: 0, index: 0)  // FlowerVertex data
        renderEncoder.setVertexBuffer(uniformBuffer, offset: 0, index: 1) // Uniforms (MVP)

        // --- Issue Draw Call for Lines ---
        renderEncoder.drawPrimitives(type: .line,           // Draw line segments
                                     vertexStart: 0,        // Start from the first vertex
                                     vertexCount: lineVertices.count) // Draw ALL vertices (count/2 lines)

        renderEncoder.endEncoding()
        commandBuffer.present(drawable)
        commandBuffer.commit()
    }
}

// MARK: - SwiftUI UIViewRepresentable

/// Bridges the FlowerRenderer's MTKView into SwiftUI.
struct MetalFlowerViewRepresentable: UIViewRepresentable {
    typealias UIViewType = MTKView

    func makeCoordinator() -> FlowerRenderer {
        guard let device = MTLCreateSystemDefaultDevice() else {
            fatalError("Metal is not supported on this device.")
        }
        guard let coordinator = FlowerRenderer(device: device) else {
            fatalError("FlowerRenderer failed to initialize.")
        }
        print("Coordinator (FlowerRenderer) created.")
        return coordinator
    }

    func makeUIView(context: Context) -> MTKView {
        let mtkView = MTKView()
        mtkView.device = context.coordinator.device
        mtkView.preferredFramesPerSecond = 60
        mtkView.enableSetNeedsDisplay = false
        mtkView.depthStencilPixelFormat = .depth32Float // Enable depth buffer
        mtkView.clearDepth = 1.0
        // Dark background similar to the image
        mtkView.clearColor = // MTLClearColor(red: 0.05, green: 0.0, blue: 0.1, alpha: 1.0) // Dark blue/purple
                           MTLClearColor(red: 0.1, green: 0.1, blue: 0.15, alpha: 1.0)  // Match octahedron BG for consistency
        mtkView.colorPixelFormat = .bgra8Unorm_srgb

        context.coordinator.configure(metalKitView: mtkView) // Setup pipeline *after* view config
        mtkView.delegate = context.coordinator
        context.coordinator.mtkView(mtkView, drawableSizeWillChange: mtkView.drawableSize) // Initial size update

        print("MTKView created and configured for Flower Pattern.")
        return mtkView
    }

    func updateUIView(_ uiView: MTKView, context: Context) {
        // No external SwiftUI state updates needed in this example.
    }
}

// MARK: - Main SwiftUI View

/// The SwiftUI view containing the title and the Metal rendering view.
struct FlowerOfLifeView: View {
    var body: some View {
        VStack(spacing: 0) {
            Text("Geometric Flower Pattern (Metal Lines)")
                .font(.headline)
                .padding()
                .frame(maxWidth: .infinity)
                .background(Color(red: 0.1, green: 0.1, blue: 0.15)) // Match Metal clear color
                .foregroundColor(.white)

            MetalFlowerViewRepresentable()
                // .ignoresSafeArea(.all) // Optional: Extend into safe areas
        }
        .background(Color(red: 0.1, green: 0.1, blue: 0.15))
        .ignoresSafeArea(.keyboard)
    }
}

// MARK: - Preview Provider

#Preview {
    // Use a Placeholder View for Previews as Metal can be unreliable in canvas
    struct PreviewPlaceholder: View {
        var body: some View {
            VStack {
                Text("Geometric Flower Pattern (Metal Lines)")
                    .font(.headline)
                    .padding().foregroundColor(.white)
                Spacer()
                Text("Metal View Placeholder\n(Run on Simulator or Device)")
                    .foregroundColor(.gray).italic().multilineTextAlignment(.center).padding()
                Spacer()
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
             .background(Color(red: 0.1, green: 0.1, blue: 0.15)) // Match expected BG
            .edgesIgnoringSafeArea(.all)
        }
    }
     //return PreviewPlaceholder() // <-- Use placeholder

    return FlowerOfLifeView() // <-- Or uncomment to try rendering real view (may fail)
}

// MARK: - Matrix Math Helper Functions (Left-Handed)
// (Copied from Octahedron example - standard matrix math)

/// Creates a perspective projection matrix (Left-Handed).
func matrix_perspective_left_hand(fovyRadians: Float, aspectRatio: Float, nearZ: Float, farZ: Float) -> matrix_float4x4 {
    let y = 1.0 / tan(fovyRadians * 0.5)
    let x = y / aspectRatio
    let z = farZ / (farZ - nearZ)
    let w = -nearZ * z
    return matrix_float4x4(
        SIMD4<Float>(x, 0, 0, 0), SIMD4<Float>(0, y, 0, 0), SIMD4<Float>(0, 0, z, 1), SIMD4<Float>(0, 0, w, 0)
    )
}

/// Creates a view matrix (Left-Handed).
func matrix_look_at_left_hand(eye: SIMD3<Float>, center: SIMD3<Float>, up: SIMD3<Float>) -> matrix_float4x4 {
    let zAxis = normalize(center - eye)
    let xAxis = normalize(cross(up, zAxis))
    let yAxis = cross(zAxis, xAxis)
    let translateX = -dot(xAxis, eye)
    let translateY = -dot(yAxis, eye)
    let translateZ = -dot(zAxis, eye)
    return matrix_float4x4(
        SIMD4<Float>( xAxis.x,  yAxis.x,  zAxis.x, 0),
        SIMD4<Float>( xAxis.y,  yAxis.y,  zAxis.y, 0),
        SIMD4<Float>( xAxis.z,  yAxis.z,  zAxis.z, 0),
        SIMD4<Float>(translateX, translateY, translateZ, 1)
    )
}

/// Creates a rotation matrix around the Z-axis.
func matrix_rotation_z(radians: Float) -> matrix_float4x4 {
    let c = cos(radians)
    let s = sin(radians)
    return matrix_float4x4(
       // Col 0        Col 1       Col 2 Col 3
       SIMD4<Float>( c, s, 0, 0), SIMD4<Float>(-s, c, 0, 0), SIMD4<Float>( 0, 0, 1, 0), SIMD4<Float>( 0, 0, 0, 1)
    )
}

/// Creates a rotation matrix around the Y-axis.
func matrix_rotation_y(radians: Float) -> matrix_float4x4 {
    let c = cos(radians)
    let s = sin(radians)
    return matrix_float4x4(
        SIMD4<Float>( c, 0, s, 0), SIMD4<Float>( 0, 1, 0, 0), SIMD4<Float>(-s, 0, c, 0), SIMD4<Float>( 0, 0, 0, 1)
    )
}

/// Creates a rotation matrix around the X-axis.
func matrix_rotation_x(radians: Float) -> matrix_float4x4 {
    let c = cos(radians)
    let s = sin(radians)
    return matrix_float4x4(
        SIMD4<Float>(1,  0, 0, 0), SIMD4<Float>(0,  c, s, 0), SIMD4<Float>(0, -s, c, 0), SIMD4<Float>(0,  0, 0, 1)
    )
}

/// Multiplies two 4x4 matrices.
func matrix_multiply(_ matrix1: matrix_float4x4, _ matrix2: matrix_float4x4) -> matrix_float4x4 {
    return matrix1 * matrix2
}

// Convenience for identity matrix
let matrix_identity_float4x4 = matrix_float4x4(diagonal: SIMD4<Float>(1,1,1,1))
